#!/usr/bin/env zsh

###############################################################################
#
# spm-helper
#
# © 2025 YOCKOW.
#   Licensed under MIT License.
#   See "LICENSE.txt" for more information.
#
################################################################################

set -eu

# Constants/Variables
################################################################################

declare -r commandName=$(basename "$0")
declare -a commandArguments=($@)
declare subcommandName=""
declare -A commonParsedArguments=(
  [help]="false"
  [package-path]="."
  [scratch-path]=".build"
  [verbose]="false"
)
declare -r -A subcommands=(
  [dep-json]='Prints the resolved dependency graph with JSON format.
              This is equivalent to `swift package show-dependencies --format json`.'
  [dep-pretty-dot]='Prints the resolved dependency graph with DOT format.'
)


# Internal Functions
################################################################################

function printError() {
  local -r message="$1"
  printf '\033[31merror:\033[m %s\n' "$message" 1>&2
}

function printWarning() {
  local -r message="$1"
  printf '\033[33mwarning:\033[m %s\n' "$message" 1>&2
}

function printInfo() {
  local -r message="$1"
  printf '\033[2minfo:\033[m %s\n' "$message" 1>&2
}

function fatalError() {
  printError "$1"
  exit 1
}

function assertionFailed() {
  local -r message="$1"
  local -r lineNumber="${2:-0}"
  echo "❗ Assertion failed (bug): line ${lineNumber}: $message" 1>&2
  exit 1
}

function isTrue() {
  local -r booleanValue="${1:-false}"
  if [[ "${(L)booleanValue}" == "true" ]]; then
    return 0
  fi
  return 1
}

function isVerbose() {
  if isTrue "${commonParsedArguments[verbose]}"; then
    return 0
  fi
  return 1
}

function shouldViewHelp() {
  if isTrue "${commonParsedArguments[help]}"; then
    return 0
  fi
  return 1
}

function verbosePrint() {
  if isVerbose; then
    printInfo "$1"
  fi
}

function requireCommand() {
  local -r requiredCommandName="$1"
  local -r howToGet="${2:-}"
  if ! command -v "$requiredCommandName" 1>/dev/null; then
    printError "Missing required command: ${requiredCommandName}"
    if [[ -n "$howToGet" ]]; then
      printInfo "Try this: ${howToGet}"
    fi
    exit 1
  fi
}

function viewCommonOptions() {
  echo "[COMMON OPTIONS]"
  echo "    --package-path <string>:"
  echo "        Path to the directory that contains Package.swift. (Default: .)"
  echo "    --scratch-path <string>:"
  echo "        Path to the scratch directory. (Default: .build)"
  echo
}

function viewHelp() {
  echo "[OVERVIEW]"
  echo "Helper tool for Swift packages."
  echo
  echo "[SYNTAX]"
  echo "$commandName <subcommand> [options]"
  echo

  echo "[SUBCOMMANDS]"
  local sub
  local line
  for sub in ${(@ok)subcommands}; do
    echo "    $sub:"
    for line in ${(ps:\n:)subcommands[$sub]}; do
      echo "        ${=${=line}}"
    done
  done
  echo

  viewCommonOptions
}


# Subcommands
################################################################################

function dep-json() {
  local -a swiftPackageShowDependenciesArguments=(
    --package-path "${commonParsedArguments[package-path]}"
    --scratch-path "${commonParsedArguments[scratch-path]}"
    show-dependencies
    --format json
  )
  if isVerbose; then
    swiftPackageShowDependenciesArguments=(
      --verbose $swiftPackageShowDependenciesArguments
    )
  fi
  swift package $swiftPackageShowDependenciesArguments
}

function dep-pretty-dot() {
  if shouldViewHelp; then
    echo "[OVERVIEW]"
    echo "${subcommands[dep-pretty-dot]}"
    echo 
    viewCommonOptions
    return 0
  fi

  local -r tmpFilePath=$(mktemp)
  dep-json >"$tmpFilePath"

  verbosePrint "Converting JSON to DOT..."
  env \
    VERBOSE_MODE="${commonParsedArguments[verbose]}" \
    JSON_PATH="$tmpFilePath" \
    swift - <<'____DOT_GENERATOR_SWIFT_CODE____'

import Foundation

let env = ProcessInfo.processInfo.environment
let isVerbose: Bool = env["VERBOSE_MODE"]?.lowercased() == "true"
let jsonPath = env["JSON_PATH"]!
let json = try String(contentsOfFile: jsonPath, encoding: .utf8)

func verbosePrint(_ message: String) {
  guard isVerbose else { return }
  try? FileHandle.standardError.write(
    contentsOf: Data("\u{1B}[2minfo:\u{1B}[m \(message)\n".utf8)
  )
}

struct PackageInfo: Decodable {
  let identity: String
  let name: String
  let url: String
  let version: String
  let path: String
  let dependencies: [PackageInfo]
}

struct DependencyLink {
  let from: PackageInfo
  let to: PackageInfo
}

verbosePrint("Decoding JSON...")
let decoder = JSONDecoder()
let rootPackage = try decoder.decode(PackageInfo.self, from: Data(json.utf8))

var allPackages: Array<PackageInfo> = []
var allLinks: Array<DependencyLink> = []

func appendPackage(_ package: PackageInfo) {
  if allPackages.allSatisfy({ $0.identity != package.identity }) {
    verbosePrint("Package: \(package.identity)(\(package.name))")
    allPackages.append(package)
  }
}

func appendLink(from: PackageInfo, to: PackageInfo) {
  if allLinks.allSatisfy({ $0.from.identity != from.identity || $0.to.identity != to.identity }) {
    verbosePrint("Link: \(from.identity)(\(from.name)) -> \(to.identity)(\(to.name))")
    allLinks.append(DependencyLink(from: from, to: to))
  }
}

func walkDependencies(of package: PackageInfo) {
  appendPackage(package)
  for dependency in package.dependencies {
    appendLink(from: package, to: dependency)
    walkDependencies(of: dependency)
  }
}

walkDependencies(of: rootPackage)

var terminals = allPackages
for link in allLinks {
  terminals.removeAll(where: { $0.identity == link.from.identity })
}
verbosePrint("Terminal packages: \(terminals.map(\.identity).joined(separator: ", "))")

verbosePrint("Generating DOT graph...")
GENERATE_DOT: do {
  print("digraph \(rootPackage.identity)DependenciesGraph {")

  // Define Nodes
  for package in allPackages.sorted(by: { $0.identity < $1.identity }) {
    if package.identity == rootPackage.identity {
      print(#"  "\#(package.identity)" [ label="\#(package.name)", shape=polygon ]"#)
    } else {
      print(#"  "\#(package.identity)" [ label="\#(package.name)\#\n@\#(package.version)", shape=oval, URL="\#(package.url)" ]"#)
    }
  }
  print("")

  // Links
  let linkSorter: (DependencyLink, DependencyLink) -> Bool = {
    if $0.from.identity < $1.from.identity {
      return true
    }
    if $0.from.identity > $1.from.identity {
      return false
    }
    if $0.to.identity < $1.to.identity {
      return true
    }
    return false
  }
  for link in allLinks.sorted(by: linkSorter) {
    print(#"  "\#(link.from.identity)" -> "\#(link.to.identity)""#)
  }
  print("")

  // Ranks
  print(#"  { rank=min; "\#(rootPackage.identity)" }"#)
  print("  { rank=max;")
  for terminal in terminals.sorted(by: { $0.identity < $1.identity }) {
    print(#"    "\#(terminal.identity)""#)
  }
  print("  }")

  // End of graph
  print("}")
}

____DOT_GENERATOR_SWIFT_CODE____
}


# Prepare
################################################################################

requireCommand swift "See https://www.swift.org/install/"

function __parseCommonArguments() {
  local -A parsedArguments=()
  zparseopts -D -E -M -A parsedArguments -- \
    -help \
    -scratch-path: \
    -package-path: \
    v -verbose=v
  commandArguments=($@)

  if [[ -n "${parsedArguments[(i)--help]}" ]]; then
    commonParsedArguments[help]="true"
  fi

  if [[ -n "${parsedArguments[(i)--scratch-path]}" ]]; then
    commonParsedArguments[scratch-path]="${parsedArguments[--scratch-path]#=}"
  fi

  if [[ -n "${parsedArguments[(i)--package-path]}" ]]; then
    commonParsedArguments[package-path]="${parsedArguments[--package-path]#=}"
  fi

  if [[ -n "${parsedArguments[(i)-v]}" ]]; then
    commonParsedArguments[verbose]="true"
    verbosePrint "Verbose mode: on"
  fi
}
__parseCommonArguments $commandArguments

if [[ ${#commandArguments[@]} -lt 1 ]]; then
  commonParsedArguments[help]="true"
else
  subcommandName="${commandArguments[1]}"
  commandArguments=($commandArguments[2,-1]) # shift
fi


# Execute
################################################################################

if [[ -z "$subcommandName" ]]; then
  verbosePrint "No subcommand name was given."
  viewHelp
  exit 0
fi

if [[ -z "${subcommands[(i)$subcommandName]}" ]]; then
  printError "Unexpected subcommand name: $subcommandName"
  viewHelp 1>&2
  exit 1
fi

$subcommandName $commandArguments