#!/usr/bin/env zsh

###############################################################################
#
# spm-helper
#
# © 2025 YOCKOW.
#   Licensed under MIT License.
#   See "LICENSE.txt" for more information.
#
################################################################################

set -eu

# Constants/Variables
################################################################################

declare -r commandName=$(basename "$0")
declare -a commandArguments=($@)
declare subcommandName=""
declare -A commonParsedArguments=(
  [help]="false"
  [package-path]="."
  [scratch-path]=".build"
  [verbose]="false"
)
declare -r -A subcommands=(
  [dep-json]='Prints the resolved dependency graph with JSON format.
              This is equivalent to `swift package show-dependencies --format json`.'
  [dep-pretty-dot]='Prints the resolved dependency graph with DOT format.'
  [dep-mermaid]='Prints the resolved dependency graph with Mermaid format.'
)


# Internal Functions
################################################################################

function printError() {
  local -r message="$1"
  printf '\033[31merror:\033[m %s\n' "$message" 1>&2
}

function printWarning() {
  local -r message="$1"
  printf '\033[33mwarning:\033[m %s\n' "$message" 1>&2
}

function printInfo() {
  local -r message="$1"
  printf '\033[2minfo:\033[m %s\n' "$message" 1>&2
}

function fatalError() {
  printError "$1"
  exit 1
}

function assertionFailed() {
  local -r message="$1"
  local -r lineNumber="${2:-0}"
  echo "❗ Assertion failed (bug): line ${lineNumber}: $message" 1>&2
  exit 1
}

function isTrue() {
  local -r booleanValue="${1:-false}"
  if [[ "${(L)booleanValue}" == "true" ]]; then
    return 0
  fi
  return 1
}

function isVerbose() {
  if isTrue "${commonParsedArguments[verbose]}"; then
    return 0
  fi
  return 1
}

function shouldViewHelp() {
  if isTrue "${commonParsedArguments[help]}"; then
    return 0
  fi
  return 1
}

function verbosePrint() {
  if isVerbose; then
    printInfo "$1"
  fi
}

function requireCommand() {
  local -r requiredCommandName="$1"
  local -r howToGet="${2:-}"
  if ! command -v "$requiredCommandName" 1>/dev/null; then
    printError "Missing required command: ${requiredCommandName}"
    if [[ -n "$howToGet" ]]; then
      printInfo "Try this: ${howToGet}"
    fi
    exit 1
  fi
}

function viewCommonOptions() {
  echo "[COMMON OPTIONS]"
  echo "    --package-path <string>:"
  echo "        Path to the directory that contains Package.swift. (Default: .)"
  echo "    --scratch-path <string>:"
  echo "        Path to the scratch directory. (Default: .build)"
  echo
}

function viewHelp() {
  echo "[OVERVIEW]"
  echo "Helper tool for Swift packages."
  echo
  echo "[SYNTAX]"
  echo "$commandName <subcommand> [options]"
  echo

  echo "[SUBCOMMANDS]"
  local sub
  local line
  for sub in ${(@ok)subcommands}; do
    echo "    $sub:"
    for line in ${(ps:\n:)subcommands[$sub]}; do
      echo "        ${=${=line}}"
    done
  done
  echo

  viewCommonOptions
}


# Subcommands
################################################################################

function dep-json() {
  local -a swiftPackageShowDependenciesArguments=(
    --package-path "${commonParsedArguments[package-path]}"
    --scratch-path "${commonParsedArguments[scratch-path]}"
    show-dependencies
    --format json
  )
  if isVerbose; then
    swiftPackageShowDependenciesArguments=(
      --verbose $swiftPackageShowDependenciesArguments
    )
  fi
  swift package $swiftPackageShowDependenciesArguments
}

function __convert-json() {
  local -A localParsedArguments=()
  zparseopts -D -E -M -A localParsedArguments -- f: -format:=f

  local outputFormat="";
  if [[ -n "${localParsedArguments[(i)-f]}" ]]; then
    outputFormat="${localParsedArguments[-f]#=}"
  fi
  if [[ "$outputFormat" != "DOT" ]] && [[ "$outputFormat" != "Mermaid" ]]; then
    assertionFailed "Unexpected format: $outputFormat" ${(%):-%I}
  fi

  local -r tmpFilePath=$(mktemp)
  dep-json >"$tmpFilePath"

  verbosePrint "Converting JSON to ${outputFormat} format..."
  env \
    VERBOSE_MODE="${commonParsedArguments[verbose]}" \
    JSON_PATH="$tmpFilePath" \
    OUTPUT_FORMAT="$outputFormat" \
    swift - <<'____JSON_CONVERTER_SWIFT_CODE____'

import Foundation

let env = ProcessInfo.processInfo.environment
let isVerbose: Bool = env["VERBOSE_MODE"]?.lowercased() == "true"
let jsonPath = env["JSON_PATH"]!
let json = try String(contentsOfFile: jsonPath, encoding: .utf8)

func verbosePrint(_ message: String) {
  guard isVerbose else { return }
  try? FileHandle.standardError.write(
    contentsOf: Data("\u{1B}[2minfo:\u{1B}[m \(message)\n".utf8)
  )
}

enum OutputFormat {
  case dot
  case mermaid

  init?(rawValue: String) {
    switch rawValue.lowercased() {
    case "dot": self = .dot
    case "mermaid": self = .mermaid
    default: return nil
    }
  }
}
guard let outputFormat = OutputFormat(rawValue: env["OUTPUT_FORMAT"]!) else {
  fatalError("Unexpected format?!")
}

struct PackageInfo: Decodable {
  let identity: String
  let name: String
  let url: String
  let version: String
  let path: String
  let dependencies: [PackageInfo]
}

struct DependencyLink {
  let from: PackageInfo
  let to: PackageInfo
}

verbosePrint("Decoding JSON...")
let decoder = JSONDecoder()
let rootPackage = try decoder.decode(PackageInfo.self, from: Data(json.utf8))

var allPackages: Array<PackageInfo> = []
var allLinks: Array<DependencyLink> = []

func walkDependencies(of package: PackageInfo) {
  func __appendPackage(_ package: PackageInfo) {
    if allPackages.allSatisfy({ $0.identity != package.identity }) {
      verbosePrint("Package: \(package.identity)(\(package.name))")
      allPackages.append(package)
    }
  }

  func __appendLink(from: PackageInfo, to: PackageInfo) {
    if allLinks.allSatisfy({ $0.from.identity != from.identity || $0.to.identity != to.identity }) {
      verbosePrint("Link: \(from.identity)(\(from.name)) -> \(to.identity)(\(to.name))")
      allLinks.append(DependencyLink(from: from, to: to))
    }
  }

  __appendPackage(package)
  for dependency in package.dependencies {
    __appendLink(from: package, to: dependency)
    walkDependencies(of: dependency)
  }
}

walkDependencies(of: rootPackage)

allPackages.sort(by: { $0.identity < $1.identity })
allLinks.sort(by: {
  if $0.from.identity < $1.from.identity {
    return true
  }
  if $0.from.identity > $1.from.identity {
    return false
  }
  if $0.to.identity < $1.to.identity {
    return true
  }
  return false
})

var terminals = allPackages
for link in allLinks {
  terminals.removeAll(where: { $0.identity == link.from.identity })
}
verbosePrint("Terminal packages: \(terminals.map(\.identity).joined(separator: ", "))")

func printDOT() {
  verbosePrint("Generating DOT graph...")

  print("digraph \(rootPackage.identity)DependenciesGraph {")

  // Define Nodes
  for package in allPackages {
    if package.identity == rootPackage.identity {
      print(#"  "\#(package.identity)" [ label="\#(package.name)", shape=polygon ]"#)
    } else {
      print(#"  "\#(package.identity)" [ label="\#(package.name)\#\n@\#(package.version)", shape=oval, URL="\#(package.url)" ]"#)
    }
  }
  print("")

  // Links
  for link in allLinks {
    print(#"  "\#(link.from.identity)" -> "\#(link.to.identity)""#)
  }
  print("")

  // Ranks
  print(#"  { rank=min; "\#(rootPackage.identity)" }"#)
  print("  { rank=max;")
  for terminal in terminals.sorted(by: { $0.identity < $1.identity }) {
    print(#"    "\#(terminal.identity)""#)
  }
  print("  }")

  // End of graph
  print("}")
}

func printMermaid() {
  MERMAID_HEADER: do {
    print("---")
    print("title: \(rootPackage.name) Dependencies")
    print("---")
  }

  print("flowchart TD")

  // Define Nodes
  for package in allPackages {
    if package.identity == rootPackage.identity {
      print(#"  \#(package.identity)["\#(package.name)"]"#)
    } else {
      print(#"  \#(package.identity)(["\#(package.name)<br>@\#(package.version)"])"#)
    }
  }
  print("")

  // URLs
  for package in allPackages where package.identity != rootPackage.identity {
    print(#"  click \#(package.identity) href "\#(package.url)""#)
  }
  print("")

  // Links
  for link in allLinks {
    let arrow: String = (
      terminals.contains(where: {
        $0.identity == link.to.identity
      }) ? "---->"
      : "-->"
    )
    print("  \(link.from.identity) \(arrow) \(link.to.identity)")
  }
  print("")
}

switch outputFormat {
case .dot: printDOT()
case .mermaid: printMermaid()
}

____JSON_CONVERTER_SWIFT_CODE____
}

function dep-pretty-dot() {
  if shouldViewHelp; then
    echo "[OVERVIEW]"
    echo "${subcommands[dep-pretty-dot]}"
    echo
    viewCommonOptions
    return 0
  fi

  __convert-json --format DOT
}

function dep-mermaid() {
  if shouldViewHelp; then
    echo "[OVERVIEW]"
    echo "${subcommands[dep-mermaid]}"
    echo
    viewCommonOptions
    return 0
  fi

  __convert-json --format Mermaid
}


# Prepare
################################################################################

requireCommand swift "See https://www.swift.org/install/"

function __parseCommonArguments() {
  local -A parsedArguments=()
  zparseopts -D -E -M -A parsedArguments -- \
    -help \
    -scratch-path: \
    -package-path: \
    v -verbose=v
  commandArguments=($@)

  if [[ -n "${parsedArguments[(i)--help]}" ]]; then
    commonParsedArguments[help]="true"
  fi

  if [[ -n "${parsedArguments[(i)--scratch-path]}" ]]; then
    commonParsedArguments[scratch-path]="${parsedArguments[--scratch-path]#=}"
  fi

  if [[ -n "${parsedArguments[(i)--package-path]}" ]]; then
    commonParsedArguments[package-path]="${parsedArguments[--package-path]#=}"
  fi

  if [[ -n "${parsedArguments[(i)-v]}" ]]; then
    commonParsedArguments[verbose]="true"
    verbosePrint "Verbose mode: on"
  fi
}
__parseCommonArguments $commandArguments

if [[ ${#commandArguments[@]} -lt 1 ]]; then
  commonParsedArguments[help]="true"
else
  subcommandName="${commandArguments[1]}"
  commandArguments=($commandArguments[2,-1]) # shift
fi


# Execute
################################################################################

if [[ -z "$subcommandName" ]]; then
  verbosePrint "No subcommand name was given."
  viewHelp
  exit 0
fi

if [[ -z "${subcommands[(i)$subcommandName]}" ]]; then
  printError "Unexpected subcommand name: $subcommandName"
  viewHelp 1>&2
  exit 1
fi

$subcommandName $commandArguments