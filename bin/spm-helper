#!/usr/bin/env zsh

###############################################################################
#
# spm-helper
#
# © 2025 YOCKOW.
#   Licensed under MIT License.
#   See "LICENSE.txt" for more information.
#
################################################################################

set -eu

# Constants/Variables
################################################################################

declare -r commandName=$(basename "$0")
declare -a commandArguments=($@)
declare subcommandName=""
declare -A commonParsedArguments=(
  [help]="false"
  [package-path]="."
  [scratch-path]=".build"
  [verbose]="false"
)
declare -r -A subcommands=(
  [collect-licenses]='Collects licenses of packages which the root package depends on.'
  [dep-json]='Prints the resolved dependency graph with JSON format.
              This is equivalent to `swift package show-dependencies --format json`.'
  [dep-pretty-dot]='Prints the resolved dependency graph with DOT format.'
  [dep-mermaid]='Prints the resolved dependency graph with Mermaid format.'
)


# Internal Functions
################################################################################

function printError() {
  local -r message="$1"
  printf '\033[31merror:\033[m %s\n' "$message" 1>&2
}

function printWarning() {
  local -r message="$1"
  printf '\033[33mwarning:\033[m %s\n' "$message" 1>&2
}

function printInfo() {
  local -r message="$1"
  printf '\033[2minfo:\033[m %s\n' "$message" 1>&2
}

function fatalError() {
  printError "$1"
  exit 1
}

function assertionFailed() {
  local -r message="$1"
  local -r lineNumber="${2:-0}"
  echo "❗ Assertion failed (bug): line ${lineNumber}: $message" 1>&2
  exit 1
}

function isTrue() {
  local -r booleanValue="${1:-false}"
  if [[ "${(L)booleanValue}" == "true" ]]; then
    return 0
  fi
  return 1
}

function isVerbose() {
  if isTrue "${commonParsedArguments[verbose]}"; then
    return 0
  fi
  return 1
}

function shouldViewHelp() {
  if isTrue "${commonParsedArguments[help]}"; then
    return 0
  fi
  return 1
}

function verbosePrint() {
  if isVerbose; then
    printInfo "$1"
  fi
}

function requireCommand() {
  local -r requiredCommandName="$1"
  local -r howToGet="${2:-}"
  if ! command -v "$requiredCommandName" 1>/dev/null; then
    printError "Missing required command: ${requiredCommandName}"
    if [[ -n "$howToGet" ]]; then
      printInfo "Try this: ${howToGet}"
    fi
    exit 1
  fi
}

function viewCommonOptions() {
  echo "[COMMON OPTIONS]"
  echo "    --package-path <string>:"
  echo "        Path to the directory that contains Package.swift. (Default: .)"
  echo "    --scratch-path <string>:"
  echo "        Path to the scratch directory. (Default: .build)"
  echo
}

function viewHelp() {
  echo "[OVERVIEW]"
  echo "Helper tool for Swift packages."
  echo
  echo "[SYNTAX]"
  echo "$commandName <subcommand> [options]"
  echo

  echo "[SUBCOMMANDS]"
  local sub
  local line
  for sub in ${(@ok)subcommands}; do
    echo "    $sub:"
    for line in ${(ps:\n:)subcommands[$sub]}; do
      echo "        ${=${=line}}"
    done
  done
  echo

  viewCommonOptions
}

function __handle-json() {
  local -A localParsedArguments=()
  zparseopts -D -E -M -A localParsedArguments -- -action:

  local actionType="";
  if [[ -n "${localParsedArguments[(i)--action]}" ]]; then
    actionType="${localParsedArguments[--action]#=}"
  fi

  local actionMessage=""
  if [[ "$actionType" = "collect-licenses" ]]; then
    actionMessage="Collecting licenses"
  elif [[ "$actionType" = "print-dot" ]]; then
    actionMessage="Converting JSON to DOT format"
  elif [[ "$actionType" = "print-flattened-json" ]]; then
    actionMessage="Converting nested JSON to flattend JSON"
  elif [[ "$actionType" = "print-mermaid" ]]; then
    actionMessage="Converting JSON to Mermaid format"
  else
    assertionFailed "Unexpected action: $actionType" ${(%):-%I}
  fi
  [[ -n "$actionMessage" ]] || assertionFailed 'Empty actionMessage?!' ${(%):-%I}

  local -r tmpFilePath=$(mktemp)
  dep-json >"$tmpFilePath"

  verbosePrint "${actionMessage}..."
  env \
    VERBOSE_MODE="${commonParsedArguments[verbose]}" \
    JSON_PATH="$tmpFilePath" \
    ACTION_TYPE="$actionType" \
    swift - <<'____JSON_HANDLER_SWIFT_CODE____'

import Foundation

let env = ProcessInfo.processInfo.environment
let isVerbose: Bool = env["VERBOSE_MODE"]?.lowercased() == "true"
let jsonPath = env["JSON_PATH"]!
let json = try String(contentsOfFile: jsonPath, encoding: .utf8)

func printError(_ message: String) {
  try? FileHandle.standardError.write(
    contentsOf: Data("\u{1B}[31merror:\u{1B}[m \(message)\n".utf8)
  )
}

func printWarning(_ message: String) {
  try? FileHandle.standardError.write(
    contentsOf: Data("\u{1B}[33mwarning:\u{1B}[m \(message)\n".utf8)
  )
}

func verbosePrint(_ message: String) {
  guard isVerbose else { return }
  try? FileHandle.standardError.write(
    contentsOf: Data("\u{1B}[2minfo:\u{1B}[m \(message)\n".utf8)
  )
}

enum ActionType {
  case collectLicenses
  case printDOT
  case printFlattenedJSON
  case printMermaid

  init?(rawValue: String) {
    switch rawValue {
    case "collect-licenses": self = .collectLicenses
    case "print-dot": self = .printDOT
    case "print-flattened-json": self = .printFlattenedJSON
    case "print-mermaid": self = .printMermaid
    default: return nil
    }
  }
}
guard let actionType = ActionType(rawValue: env["ACTION_TYPE"]!) else {
  fatalError("Unexpected action type?!")
}

struct PackageInfo: Codable {
  let identity: String
  let name: String
  let url: String
  let version: String
  let path: String
  let dependencies: [PackageInfo]
}

struct DependencyLink {
  let from: PackageInfo
  let to: PackageInfo
}

struct GraphSource {
  let allPackages: Array<PackageInfo>
  let allLinks: Array<DependencyLink>
  let terminals: Array<PackageInfo>
}

struct JSONHandlerError: Error {
  let message: String
}

verbosePrint("Decoding JSON...")
let decoder = JSONDecoder()
let rootPackage = try decoder.decode(PackageInfo.self, from: Data(json.utf8))
let graphSource = ({ () -> GraphSource in
  var allPackages: Array<PackageInfo> = []
  var allLinks: Array<DependencyLink> = []

  func walkDependencies(of package: PackageInfo) {
    func __appendPackage(_ package: PackageInfo) {
      if allPackages.allSatisfy({ $0.identity != package.identity }) {
        verbosePrint("Package: \(package.identity)(\(package.name))")
        allPackages.append(package)
      }
    }

    func __appendLink(from: PackageInfo, to: PackageInfo) {
      if allLinks.allSatisfy({ $0.from.identity != from.identity || $0.to.identity != to.identity }) {
        verbosePrint("Link: \(from.identity)(\(from.name)) -> \(to.identity)(\(to.name))")
        allLinks.append(DependencyLink(from: from, to: to))
      }
    }

    __appendPackage(package)
    for dependency in package.dependencies {
      __appendLink(from: package, to: dependency)
      walkDependencies(of: dependency)
    }
  }

  walkDependencies(of: rootPackage)

  allPackages.sort(by: { $0.identity < $1.identity })
  allLinks.sort(by: {
    if $0.from.identity < $1.from.identity {
      return true
    }
    if $0.from.identity > $1.from.identity {
      return false
    }
    if $0.to.identity < $1.to.identity {
      return true
    }
    return false
  })

  var terminals = allPackages
  for link in allLinks {
    terminals.removeAll(where: { $0.identity == link.from.identity })
  }
  verbosePrint("Terminal packages: \(terminals.map(\.identity).joined(separator: ", "))")

  return GraphSource(
    allPackages: allPackages,
    allLinks: allLinks,
    terminals: terminals
  )
})()
var allPackages: Array<PackageInfo> { graphSource.allPackages }
var allLinks: Array<DependencyLink> { graphSource.allLinks }
var terminals: Array<PackageInfo> { graphSource.terminals }

let jsonEncoder: JSONEncoder = ({
  let encoder = JSONEncoder()
  encoder.outputFormatting = [
    .prettyPrinted,
    .withoutEscapingSlashes,
  ]
  return encoder
})()
let fileManager = FileManager.default

/* ***** Each Action ***** */

func collectLicenses() throws {
  struct __LicenseMetadata: Encodable {
    let name: String
    let url: String?
    let version: String?
    let filenames: [String: String]
  }

  func __isExistingDirectory(at path: URL) -> Bool {
    var isDir: ObjCBool = false
    let result = fileManager.fileExists(atPath: path.path, isDirectory: &isDir)
    return result && isDir.boolValue
  }

  func __isExistingFile(at path: URL) -> Bool {
    var isDir: ObjCBool = false
    let result = fileManager.fileExists(atPath: path.path, isDirectory: &isDir)
    return result && !(isDir.boolValue)
  }

  func __isLicenseFile(forFilename filename: String) -> Bool {
    let uppercasedFilename = filename.uppercased()

    func ____matchesWithOrWithoutFileExtension(_ string: String) -> Bool {
      return (
        uppercasedFilename == string ||
        uppercasedFilename.hasPrefix("\(string).")
      )
    }

    return [
      "COPYING",
      "COPYRIGHT",
      "LICENSE",
      "NOTICE",
    ].contains(where: ____matchesWithOrWithoutFileExtension)
  }

  func __convertLicenseFilename(_ filename: String, for package: PackageInfo) -> String {
    let splitted = filename.split(separator: ".", maxSplits: 1, omittingEmptySubsequences: true)
    let filenameCore = splitted[0]
    let pathExtension: Substring = splitted.count > 0 ? splitted[1] : "txt"
    return "swift-package-\(package.identity)-\(filenameCore).\(pathExtension)"
  }

  func __write(data: Data, to path: URL) throws {
    let tmpPath = path.appendingPathExtension("tmp")
    if __isExistingFile(at: tmpPath) {
      verbosePrint("Removing temporary file at \"\(tmpPath.path)\"...")
      try fileManager.removeItem(at: tmpPath)
    }

    if !__isExistingFile(at: path) {
      guard fileManager.createFile(atPath: path.path, contents: data) else {
        throw JSONHandlerError(message: "Failed to create a file at \"\(path.path)\".")
      }
      return
    }

    verbosePrint("Writing data to \"\(tmpPath.path)\"...")
    guard fileManager.createFile(atPath: tmpPath.path, contents: data) else {
      throw JSONHandlerError(message: "Failed to create a file at \"\(tmpPath.path)\".")
    }
    verbosePrint("Moving file at \"\(tmpPath.path)\" to \"\(path.path)\"...")
    try fileManager.removeItem(at: path)
    try fileManager.moveItem(at: tmpPath, to: path)
  }

  func __copyFile(at srcPath: URL, to destPath: URL) throws {
    verbosePrint(#"Copying "\#(srcPath.path)" to "\#(destPath.path)"..."#)
    let tmpDestPath = destPath.appendingPathExtension("tmp")
    if __isExistingFile(at: tmpDestPath) {
      verbosePrint("Removing temporary file at \"\(tmpDestPath.path)\"...")
      try fileManager.removeItem(at: tmpDestPath)
    }
    try fileManager.copyItem(at: srcPath, to: tmpDestPath)
    if __isExistingFile(at: destPath) {
      try fileManager.removeItem(at: destPath)
    }
    try fileManager.moveItem(at: tmpDestPath, to: destPath)
  }

  guard let licensesDirectory = env["USER_INFO__DIRECTORY"].map({ URL(filePath: $0) }),
        __isExistingDirectory(at: licensesDirectory)
  else {
    fatalError("Missing directory?!")
  }
  verbosePrint("License files will be saved in the directory at \"\(licensesDirectory.path)\".")

  let saveMetadata: Bool = env["USER_INFO__SAVE_METADATA"].map({ $0 == "true" }) ?? false
  if saveMetadata {
    verbosePrint("Metadata files will be also saved.")
  }

  for package in allPackages where package.identity != rootPackage.identity {
    verbosePrint("Searching license files for \(package.identity)(\(package.name))...")

    let pkgPath = URL(filePath: package.path)
    guard __isExistingDirectory(at: pkgPath) else {
      printWarning("Directory doesn't exist at \(pkgPath.path), which should be the repository for \(package.identity)(\(package.name)).")
      continue
    }

    let allFilenames = try fileManager.contentsOfDirectory(atPath: package.path)
    var licenseFilenames: [String] = []
    for filename in allFilenames {
      let filePath = pkgPath.appending(component: filename)
      guard __isExistingFile(at: filePath) else {
        verbosePrint("Skipping \"\(filename)\" because it is not a file...")
        continue
      }
      if __isLicenseFile(forFilename: filename) {
        verbosePrint("License file found: \"\(filename)\".")
        licenseFilenames.append(filename)
      } else {
        verbosePrint("\"\(filename)\" doesn't seem to be a license file.")
      }
    }
    if licenseFilenames.isEmpty {
      printWarning("No license files found for \(package.identity)(\(package.name)).")
      continue
    }

    let metadata = __LicenseMetadata(
      name: package.name,
      url: package.url,
      version: package.version == "unspecified" ? nil : package.version,
      filenames: Dictionary<String, String>(
        uniqueKeysWithValues: licenseFilenames.map {
          ($0, __convertLicenseFilename($0, for: package))
        }
      )
    )
    if saveMetadata {
      verbosePrint("Saving metadata file...")
      let metadataPath = licensesDirectory.appending(
        component: "metadata",
        directoryHint: .isDirectory
      ).appending(
        component: "swift-package-\(package.identity).json",
        directoryHint: .notDirectory
      )
      let metadataJSON = try jsonEncoder.encode(metadata)
      try __write(data: metadataJSON, to: metadataPath)
    }

    for (originalFilename, convertedFilename) in metadata.filenames {
      try __copyFile(
        at: pkgPath.appending(component: originalFilename),
        to: licensesDirectory.appending(component: convertedFilename)
      )
    }
  }
}

func printDOT() {
  verbosePrint("Generating DOT graph...")

  print("digraph \(rootPackage.identity)DependenciesGraph {")

  // Define Nodes
  for package in allPackages {
    if package.identity == rootPackage.identity {
      print(#"  "\#(package.identity)" [ label="\#(package.name)", shape=polygon ]"#)
    } else {
      print(#"  "\#(package.identity)" [ label="\#(package.name)\#\n@\#(package.version)", shape=oval, URL="\#(package.url)" ]"#)
    }
  }
  print("")

  // Links
  for link in allLinks {
    print(#"  "\#(link.from.identity)" -> "\#(link.to.identity)""#)
  }
  print("")

  // Ranks
  print(#"  { rank=min; "\#(rootPackage.identity)" }"#)
  print("  { rank=max;")
  for terminal in terminals.sorted(by: { $0.identity < $1.identity }) {
    print(#"    "\#(terminal.identity)""#)
  }
  print("  }")

  // End of graph
  print("}")
}

func printFlattenedJSON() throws {
  verbosePrint("Flattening JSON...")

  let jsonData = try jsonEncoder.encode(allPackages)
  try FileHandle.standardOutput.write(contentsOf: jsonData)
}

func printMermaid() {
  MERMAID_HEADER: do {
    print("---")
    print("title: \(rootPackage.name) Dependencies")
    print("---")
  }

  print("flowchart TD")

  // Define Nodes
  for package in allPackages {
    if package.identity == rootPackage.identity {
      print(#"  \#(package.identity)["\#(package.name)"]"#)
    } else {
      print(#"  \#(package.identity)(["\#(package.name)<br>@\#(package.version)"])"#)
    }
  }
  print("")

  // URLs
  for package in allPackages where package.identity != rootPackage.identity {
    print(#"  click \#(package.identity) href "\#(package.url)""#)
  }
  print("")

  // Links
  for link in allLinks {
    let arrow: String = (
      terminals.contains(where: {
        $0.identity == link.to.identity
      }) ? "---->"
      : "-->"
    )
    print("  \(link.from.identity) \(arrow) \(link.to.identity)")
  }
  print("")
}

do {
  switch actionType {
  case .collectLicenses: try collectLicenses()
  case .printDOT: printDOT()
  case .printFlattenedJSON: try printFlattenedJSON()
  case .printMermaid: printMermaid()
  }
} catch let jsonHandlerError as JSONHandlerError {
  printError(jsonHandlerError.message)
  throw jsonHandlerError
} catch {
  print(error.localizedDescription)
  throw error
}

____JSON_HANDLER_SWIFT_CODE____
}

# Subcommands
################################################################################

function collect-licenses() {
  if shouldViewHelp; then
    echo "[OVERVIEW]"
    echo "${subcommands[collect-licenses]}"
    echo
    viewCommonOptions
    echo
    echo "[OPTIONS]"
    echo "    -d/--directory <path>:"
    echo "        Path to the directory where license files are saved."
    echo "    --metadata: Save also metadata files."
    echo "    -y/--yes: Assume Yes on all queries."
    return 0
  fi

  local -A localParsedArguments=()
  zparseopts -D -E -M -A localParsedArguments -- \
    d: -directory:=d \
    -metadata -save-metadata=-metadata \
    y -yes=y -assume-yes=y

  local licensesDirectory=""
  local saveMetadata="false"
  local assumeYes="false"
  if [[ -n "${localParsedArguments[(i)-d]}" ]]; then
    licensesDirectory="${localParsedArguments[-d]#=}"
  fi
  if [[ -n "${localParsedArguments[(i)--metadata]}" ]]; then
    saveMetadata="true"
  fi
  if [[ -n "${localParsedArguments[(i)-y]}" ]]; then
    assumeYes="true"
    verbosePrint "Assume Yes: true"
  fi

  if [[ -d "$licensesDirectory" ]]; then
    if ! isTrue "$assumeYes"; then
      printWarning "Are you sure the license files will be overwritten in the directory \"$licensesDirectory\"? [y/N]"
      if ! read -q; then
        verbosePrint "Operation Aborted."
        return 0
      fi
    fi
  else
    verbosePrint "Creating directory at \"$licensesDirectory\"..."
    mkdir -p "$licensesDirectory"
  fi
  if isTrue "$saveMetadata"; then
    mkdir -p "${licensesDirectory}/metadata"
  fi

  export USER_INFO__DIRECTORY="$(cd "$licensesDirectory" && pwd)"
  export USER_INFO__SAVE_METADATA="$saveMetadata"

  __handle-json --action collect-licenses
}

function dep-json() {
  local -A localParsedArguments=()
  zparseopts -D -E -M -A localParsedArguments -- -flattened

  local flattened="false"
  if [[ -n "${localParsedArguments[(i)--flattened]}" ]]; then
    flattened="true"
  fi

  local -a swiftPackageShowDependenciesArguments=(
    --package-path "${commonParsedArguments[package-path]}"
    --scratch-path "${commonParsedArguments[scratch-path]}"
    show-dependencies
    --format json
  )
  if isVerbose; then
    swiftPackageShowDependenciesArguments=(
      --verbose $swiftPackageShowDependenciesArguments
    )
  fi

  if isTrue "$flattened"; then
    __handle-json --action print-flattened-json
  else
    swift package $swiftPackageShowDependenciesArguments
  fi
}

function dep-pretty-dot() {
  if shouldViewHelp; then
    echo "[OVERVIEW]"
    echo "${subcommands[dep-pretty-dot]}"
    echo
    viewCommonOptions
    return 0
  fi

  __handle-json --action print-dot
}

function dep-mermaid() {
  if shouldViewHelp; then
    echo "[OVERVIEW]"
    echo "${subcommands[dep-mermaid]}"
    echo
    viewCommonOptions
    return 0
  fi

  __handle-json --action print-mermaid
}


# Prepare
################################################################################

requireCommand swift "See https://www.swift.org/install/"

function __parseCommonArguments() {
  local -A parsedArguments=()
  zparseopts -D -E -M -A parsedArguments -- \
    -help \
    -scratch-path: \
    -package-path: \
    v -verbose=v
  commandArguments=($@)

  if [[ -n "${parsedArguments[(i)--help]}" ]]; then
    commonParsedArguments[help]="true"
  fi

  if [[ -n "${parsedArguments[(i)--scratch-path]}" ]]; then
    commonParsedArguments[scratch-path]="${parsedArguments[--scratch-path]#=}"
  fi

  if [[ -n "${parsedArguments[(i)--package-path]}" ]]; then
    commonParsedArguments[package-path]="${parsedArguments[--package-path]#=}"
  fi

  if [[ -n "${parsedArguments[(i)-v]}" ]]; then
    commonParsedArguments[verbose]="true"
    verbosePrint "Verbose mode: on"
  fi
}
__parseCommonArguments $commandArguments

if [[ ${#commandArguments[@]} -lt 1 ]]; then
  commonParsedArguments[help]="true"
else
  subcommandName="${commandArguments[1]}"
  commandArguments=($commandArguments[2,-1]) # shift
fi


# Execute
################################################################################

if [[ -z "$subcommandName" ]]; then
  verbosePrint "No subcommand name was given."
  viewHelp
  exit 0
fi

if [[ -z "${subcommands[(i)$subcommandName]}" ]]; then
  printError "Unexpected subcommand name: $subcommandName"
  viewHelp 1>&2
  exit 1
fi

$subcommandName $commandArguments